---
format: live-html
pa_num: 10
pa_title: "Strings and Things"
---

{{< include _gradethis_init.qmd >}}

{{< include _pa_setup.qmd >}}

This week, we begin to study the world of text data. While numerical data is 
reasonably straight-forward to deal with, text data is remarkably complex. A 
full discussion of text data requires understanding the vast world of human written
language, but we will discuss enough of the major points to hopefully solve 95% 
of the challenges you will face in your career.


## Goals

In our quest to understand text data, we have two major goals:

- Understanding String Encodings and Unicode
- Manipulating Strings with Regular Expressions

Before we get into these, let's begin with a basic review of the 
_character_ data type in _R_. 

## String Vectors

Recall that _R_ works by default on _vectors_ - ordered collections of the
"same sort"  of thing. _R_ supports the following vector types:

- **Raw** for pure access to bytes without any additional meaning: rarely useful
  for pure data-analytic work, but commonly used to interact with binary file
  formats and with non-`R` software
- **Integer**: 32-bit signed integers, ranging from $-2^{30}$ to $2^{30}-1$. 
  (If you have done low-level work before, you might ask where the extra bit
  went: it's used for encoding _NA_ values.)
- **Numeric**: 64-bit (double precision) floating point values, ranging from 
  0 to (approximately) $\pm 10^{308}$. The detailed behavior of numeric 
  (often called double) data is beyond this course, but it is well 
  [documented elsewhwere](https://dl.acm.org/doi/10.1145/103162.103163).
- **Character**: the topic of today's discussion. 

*R* makes no difference between a *character* -in the sense of a single letter-
and a *string*: in particular, each *element* of a *character vector* is an 
(arbitrary length) string. Specialized functions are required for work at the
true "single letter" scale. If you come from other languages, this behavior might
be surprising, but it allows *R* to handle much of the complexity associated with 
characters 'auto-magically', which greatly simplifies data analysis.

When speaking, I often refer to *R* as using _strings_ because of this 
flexibility, even if *R*  itself calls them character elements for 
historical reasons.

## Encoding

How are strings represented on a computer? The answer has evolved over time, but
the current state of the art - used by almost all non-legacy software - is based
on the *Unicode system* and the *UTF-8* encoding. 

The *Unicode system* is comprised of two essential parts: 

- A numbered list of "letter-like" elements
- Rules for manipulating those elements

While this seems simple, it is anything but. The history of string representations
in computers is a long and painful story of programmers repeatedly underestimating
the complexity of the seemingly simple task of listing "all the letters." 

The Unicode consortium makes a long list of characters that computers should be able
to represent: the most recent version of the Unicode standard 
([Version 17.0](https://www.unicode.org/versions/Unicode17.0.0/) released
2025-09-09) includes 159,801 characters divided into 172 scripts. These include 
everything from the basic (Anglo-American) Latin alphabet to the Greek and 
Cyrillic alphabets to Chinese and Japanese characters to the undeciphered 
[Linear A alphabet](https://en.wikipedia.org/wiki/Linear_A) and Tengwar, 
the fictional script used in the Lord of the Rings novels. The Unicode standard 
also includes a wide set of 
[Emoji (approximately 4000)](https://www.unicode.org/emoji/charts/full-emoji-list.html)
and many "modifying" characters.[^emoji] Recent additions include a Big Foot 
emoji, an Avalanche Emoji, and a Trombone Emoji. 

[^emoji]: Technically, the Unicode consortium releases two standards, Unicode 17
and Emoji 17, but we're not going to worry about this level of detail.

To each of these, the Unicode consortium assigns a _code point_ : a numerical 
identifier.  Even superficially similar characters may be assigned different 
code points to distinguish them: for example, "H" is code point U+0048 with the 
official description "Latin Capital Letter H" while "Î—" is U+0397, "Greek 
Capital Letter Eta." 

Visually, these look identical, but the difference between these characters is 
essential to know how to manipulate them: 

```{webr}
x <- "H"
y <- "Î—"
```

Use the `tolower` function to lower-case each of these:

```{webr}
x <- "H"
y <- "Î—"

cat("The lower case of", x, "is", tolower(x), "\n")
cat("The lower case of", y, "is", tolower(y), "\n")
```

The Unicode standard defines the lower case mapping of U+0048 as the Latin 
lower case h (U+0068), while the lower case mapping of U+0397 is the Greek 
lower case  eta (U+03B7), which looks something like a _streched_ n. 

The `Unicode` package provides some tools to investigate these: 

```{webr}
library(Unicode)

get_unicode_info <- function(x){
    Unicode::u_char_inspect(Unicode::as.u_char(utf8ToInt(x)))
}

get_unicode_info(x)
get_unicode_info(y)
```

In general, these sorts of 'case-fold' mappings are _incredibly_ complicated 
and depend not only on the specific code point, but also the set of translation
rules being used. (For 
[historical and political reasons](https://stackoverflow.com/a/48068389), 
certain languages have different lower/upper mappings for what are otherwise 
the same letter in Unicode.)

While you don't need to know all of this complexity, it is essential to know that 
it's out there and to rely on battle-tested libraries to perform these mappings. 

Unicode is supplemented by the `UTF-8` encodings, which controls how 0/1-bit strings
are actually translated to code points. (Fonts then map code points to what you see
on the screen.) UTF-8 is more-or-less back-compatible with other major encodings, 
so it's a good default. When dealing with modern websites or public data sources, they
almost always present their contents in a `UTF-8` compatible encoding (if not `UTF-8` proper)
so you should be ok. 

A well-formatted website will state its encoding near the top of the page: 

```{r}
#| message: false
library(rvest)
read_html("http://www.baruch.cuny.edu") |>
    html_elements("meta[charset]") |>
    html_attr("charset")
```

**Advice**: Whenever possible, make sure you are using *UTF-8* strings: if your data
is not *UTF-8*, reencode it to *UTF-8* as soon as possible. This will save you much
pain. 

## String Manipulation

Once data is in _R_ and encoded as UTF-8 Unicode points, we have several tools
for dealing with strings. Your first port of call should be the 
[`stringr`](https://stringr.tidyverse.org) package. 

All the functions of the `stringr` package start with `str_` and take a vector
of strings as the first argument, making them well suited for chained analysis. 

Let's start with `str_length` which simply computes the length of each element. 
For the basic Latin alphabet, this more or less matches our intuition: 

```{webr}
library(stringr)
x <- c("I", "am", "a", "student", "at", "Baruch.")
str_length(x)
```

but it can be tricky for strings that involve Unicode _combining characters_. 

```{webr}
library(stringr)
str_length("XÌ…")
```

Here the "overbar" is a combining character which we add on to the `X`. This is
commonly (though not always) used for languages with accents (*e.g.* French) or 
for languages where vowels are written above and below the main script 
(Arabic or Hebrew).  This same idea is used for certain Emoji constructs: 

```{webr}
library(stringr)
str_length("ðŸ‘¨ðŸ¿")
```

Here, "Man with Dark Skin Tone" is the combination of "Man" and "Dark Skin Tone."
(Compare how this appears in your browser to how RStudio prints it if you copy
this code to your computer.)

While there is complexity in all of Unicode, `str_length` will behave as you might 
expect for "regular" text. I'm going to stop showing the "scary side" of Unicode, 
but you should be aware of it for the remainder of these exercises.

### Concatenation

You have already seen the base `paste` and `paste0` functions for combining
two string vectors together. 

```{webr}
x <- c("Michael", "Mary", "Gus")
y <- c("Son", "Daughter", "Dog")

paste(x, y)
```

By default, `paste` combines strings with a space between them, while `paste0` omits
the space. `paste` is typically what you want for strings for human reading, while `paste0`
is a better guess for computer-oriented text (*e.g.*, putting together a URL).

You can change the separator by passing a `sep` argument to paste:

```{webr}
paste(x, y, sep = " is my ")
```

You can also combine together multiple elements of a vector using the `collapse`
argument:

```{webr}
paste(x, collapse = " and ")
```

#### Exercises:

1. Using the `paste` function, make a vector of strings like 
   "John's favorite color is blue" from the following data: 

```{webr}
people <- c("John", "Jane", "Randy", "Tammi")
colors <- c("blue", "orange", "grey", "chartreuse")
```

::: {.callout-tip title="Solution" collapse="true"}

```{webr}
paste(people, colors, sep = "'s favorite color is ")
```

:::

2. Modify your answer to write a (run-on) sentence of favorite colors: 
   "John's favorite color is blue and Jane's favorite color is orange and ..."


::: {.callout-tip title="Solution" collapse="true"}

```{webr}
paste(people, colors, sep = "'s favorite color is ", collapse = " and ")
```

Note that this does not provide terminating punctuation.

:::


### Substring Selection

When cleaning up data for analysis, it is common to need to take _substrings_ 
from larger text. The `str_sub` function will do this for a fixed length: 

```{webr}
library(stringr)

x <- c("How", "much", "is", "that", "puppy", "in", "the", "window?")
str_sub(x, 1, 2)

str_sub(x, 1, 3)
```

This behavior is useful when you are trying to extract a single piece from a
longer bit of consistently formatted text, *e.g.*, a computer log file or a
set of IDs. 

If you want to go all the way to the end, set the end element to `-1`: 

```{webr}
library(stringr)

str_sub(x, 2, -1)
```

#### Exercises

Using `str_sub`, remove the system name (CUNY or UC) and return only the campus name:

```{webr}
library(stringr)

uc_schools <- c("UC Berkeley", "UC San Diego", "UC Santa Cruz", "UC Davis")
cuny_schools <- c("Baruch College, CUNY", "City College, CUNY", 
                  "La Guardia Community College, CUNY")
```

::: {.callout-tip title="Solution" collapse="true"}

```{webr}
library(stringr)

uc_schools <- c("UC Berkeley", "UC San Diego", "UC Santa Cruz", "UC Davis")
cuny_schools <- c("Baruch College, CUNY", "City College, CUNY", 
                  "La Guardia Community College, CUNY")

str_sub(uc_schools, 4, -1)
str_sub(cuny_schools, 1, -7)
```

:::
### Detect and Matching

Often we only need to know whether a particular substring is present in 
a larger string.  We can use `str_detect` to do this: 

```{webr}
library(stringr)

dogs <- c("basset hound", 
          "greyhound", 
          "labrador retreiver", 
          "border collie", 
          "Afgahn hound")

str_detect(dogs, "hound")

# If we want those dogs where hound is its own word (i.e., not greyhound)
# we can put a space before "hound"
str_detect(dogs, " hound")
```

This is particularly useful inside of `dplyr` commands: 

```{webr}
library(tidyverse)
dog_frame <- tribble(
    ~breed, ~weight, 
    "basset hound", 65, 
    "greyhound", 74, 
    "labrador retreiver", 73,  
    "border collie", 43, 
    "Afgahn hound", 52
)

dog_frame |>
    mutate(is_hound = str_detect(breed, "hound")) |>
    group_by(is_hound) |>
    summarize(weight = mean(weight))
```
    

The `str_match` function will return the *text* of the match. 
Here it's useless, but we'll  see that it becomes more powerful when we 
allow more flexible pattern specifications.

```{webr}
library(stringr)

dogs <- c("basset hound", 
          "greyhound", 
          "labrador retreiver", 
          "border collie", 
          "Afgahn hound")

str_match(dogs, "hound")
```

The `str_subset` function will return only those strings which match 
a certain pattern: 

```{webr}
library(stringr)

dogs <- c("basset hound", 
          "greyhound", 
          "labrador retreiver", 
          "border collie", 
          "Afgahn hound")

str_subset(dogs, "hound")
```

#### Exercises

Use `str_subset` to find the CUNY schools:

```{webr}
library(stringr)
schools <- c("UC Davis", 
             "UC Santa Cruz", 
             "City College, CUNY", 
             "UC Berkeley", 
             "La Guardia Community College, CUNY", 
             "Baruch College, CUNY", 
             "UC San Diego")
```

::: {.callout-tip title="Solution" collapse=true}

```{webr}
library(stringr)
schools <- c("UC Davis", 
             "UC Santa Cruz", 
             "City College, CUNY", 
             "UC Berkeley", 
             "La Guardia Community College, CUNY", 
             "Baruch College, CUNY", 
             "UC San Diego")
str_subset(schools, "CUNY")
```

:::


### Specifying Patterns

While working by individual characters is sometimes useful (for very predictably
formatted data), we generally need more powerful tools: _regular expressions_ 
(RE) provide a compact language for specifying patterns in strings. We'll 
introduce the basics here to help with string functions and then explore some 
more advanced RE features. 

The most basic pattern is a set of elements in brackets: this means "any of these". 

For example, we want to see which names have an "A" in them: 

```{webr}
library(stringr)

names <- c("Jane", "Rhonda", "Reggie", "Bernie", "Walter", "Arthur")

str_detect(names, "a") ## Wrong!
str_detect(names, "A") ## Wrong!
str_detect(names, "[Aa]") ## Right!
```

Here, we consider a string to be a match if it has an `A`, an `a` or both. 

Alternatively, we can see which strings contain numbers: 

```{webr}
library(stringr)

x <- c("73 cows", "47 chickens", "a dozen eggs")
str_detect(x, "[0123456789]")
```

If we use `str_match` we can pull out the matching element: 

```{webr}
library(stringr)

x <- c("2 burgers", "3 soups", "5 fish")
str_match(x, "[0123456789]")
```

By default, this only finds _one_ appearance of the pattern: 

```{webr}
library(stringr)

x <- c("23 burgers", "34 soups", "56 fish")

# Why is this wrong?
str_match(x, "[0123456789]")
```

We can modify the pattern specifier to include count information. The basic 
behavior is to add explicit count bounds:

```{webr}
library(stringr)

x <- c("2 burgers", "34 soups", "567 fish")
str_match(x, "[0123456789]{2}")
str_match(x, "[0123456789]{3}")
str_match(x, "[0123456789]{2,3}")
str_match(x, "[0123456789]{2,}")
```

Here a single number is an exact count (`{2}`), while pairs (`{2,3}`) 
specify a range.  If one end of the range is left empty, it is 0 or infinite 
(depending on the direction). 

Certain count specifications are sufficiently useful to get their own syntax:

- One or more: `+` is equivalent to `{1,}`
- Zero or more: `*` is equivalent to `{0,}` 
- One or zero: `?` is equivalent to `{0,1}`.

Use these specifications for the next set of exercises.

#### Exercises

1. Which strings contain a three digit number? 

```{webr}
library(stringr)
x <- c("2 burgers", "34 soups", "567 fish")
```

::: {.callout-tip title="Solution" collapse="true"}

```{webr}
library(stringr)
x <- c("2 burgers", "34 soups", "567 fish")
str_subset(x, "[0123456789]{3}")
```

A more compact way of writing `[0123456789]` is `\\d`, so this could also be
done with

```{webr}
library(stringr)
x <- c("2 burgers", "34 soups", "567 fish")
str_subset(x, "\\d{3}")
```

:::


### Combining patterns

You can combine REs to make more complex patterns: 

- `(a|b)` means `a` or `b`. This is like `[]` notation but `a`, `b` can be more
  complex than single characters. For example, we can detect schools that are
  either CUNY or UC: 
  
```{webr}
x <- c("Baruch College, CUNY", "UC Berkeley", "Harvard University")
str_subset(x, "(CUNY|UC)")
```

- `[^abc]` means _anything other than_ `a`, `b`, `c`. You can often achieve a 
  similar effect using the `negate` argument to `str_detect`, but you need this
  specifically for `str_match`

```{webr}
x <- c("10234", "three", "15 otters")
str_subset(x, "[^0123456789]") # Find strings that aren't all numbers

x <- c("FRANCE", "France", "french fries")
str_subset(x, "[^A-Z]") # Find strings that aren't all capital letters
```

  Note that this does not require that _all_ elements of the string don't match,
  only that at least one character doesn't fall in the specified range. If you
  want to have no matches, the `negate=TRUE` argument can help:[^neg]

```{webr}
x <- c("10234", "three", "15 otters")
str_subset(x, "[0123456789]", negate=TRUE) # Find strings have no digits

x <- c("FRANCE", "France", "french fries")
str_subset(x, "[A-Z]", negate=TRUE) # Find strings have no capital letters
```

- `^` outside of a bracket denotes the start of a line: 

```{webr}
x <- c("rum", "white rum", "flavored rum", "rum and coke")
str_subset(x, "^rum")
```

- `$` denotes the end of a line: 

```{webr}
x <- c("bourbon whiskey", "scotch whisky", "whiskey liqueurs")
str_subset(x, "whiske?y$")
```

Note that we made the `e` optional here, so we matched both the American 
(whiskey) and the Scottish spelling (whisky) of a distilled grain spirit.

See [the stringr RE docs](https://stringr.tidyverse.org/articles/regular-expressions.html)
for more examples of regular expressions. 

[^neg]: Not all langauges or functions have an equivalent to the `negate=TRUE`
argument. We can get a similar effect using markers for beginning and end (see
below) along with quanitifers, but the logic is a bit trickier:

    ```{webr}
x <- c("10234", "three", "15 otters")
str_subset(x, "^[^0123456789]+$") # Find strings have no digits

x <- c("FRANCE", "France", "french fries")
str_subset(x, "^[^A-Z]+$", negate=TRUE) # Find strings have no capital letters
    ```

#### Exercises

1. Use a regular expression to find which of these are fish species:

```{webr}
library(stringr)
x <- c("clownfish", "goldfish", "fish food")
```

::: {.callout-tip title="Solution" collapse="true"}

```{webr}
library(stringr)
x <- c("clownfish", "goldfish", "fish food")
str_subset(x, "fish$")
```

:::

2. Use a regular expression to find words with three or more vowels in a row:

```{webr}
library(stringr)
x <- c("haaar", "xjjejeje", "youins", "exigent")
```

::: {.callout-tip title="Solution" collapse="true"}

```{webr}
library(stringr)
x <- c("haaar", "xjjejeje", "youins", "exigent")
str_subset(x, "[aeiou]{3,}")
```

:::

3. Find the words where "q" is not followed by a "u"

```{webr}
library(stingr)
x <- c("queen", "quiet", "qipao", "coq au vin")
```

::: {.callout-tip title="Solution" collapse="true"}

```{webr}
library(stingr)
x <- c("queen", "quiet", "qipao", "coq au vin")
str_subset(x, "q[^u]")
```

:::

### Replacement

The `str_replace` function allows us to replace a string with something else. 
This is particularly useful when cleaning up text: 

```{webr}
x <- c("Manhattan, NY", "Bronx, New York", "Brooklyn, ny", "Queens, Ny")
str_replace(x, "([nN][yY]|New York)", "NY")
```

Note that this replace only the _first_ match in a string: 

```{webr}
str_replace("The best city in NY in NY City", "NY", "New York")
```

In some circumstances, you may want to replace _all_ matches, and should instead
use `str_replace_all`: 

```{webr}
str_replace_all("The best city in NY in NY City", "NY", "New York")
```

### Character Classes

Some patterns are so common with regular expressions that 'shorthand' is given
for them: 

- `\d` is short-hand for the set of digits `[0123456789]`
- `\D` is short-hand for _non-digits_ `[^0123456789]`
- `\s` is short-hand for any sort of space (space, newline, tab, *etc.*)
- `\S` is short-hand for anything that is not a space
- `\w` is short-hand for the 'normal word elements' of basic English: `[A-Za-z0-9_]`,
   that is, all digits, upper case letters, lower case letters, or an underscore
- `\W` is short-hand for anything not in `\w`: `[^A-Za-z0-9_]`

Use of these is not required, but they are recommended as they will save some
typing and be a bit more robust: *e.g.*, you might think you are covering all
letters with `[A-Za-z]` but unexpected accented letters might throw you off: 

```{webr}
str_detect("Ã‰clair", "[A-Za-z]{6}")
str_detect("Ã‰clair", "\\S{6}")
```

One word of warning that can be a bit tricky: when using these, you will
typically need to put a _double-slash_ in front of the character class name, 
*e.g.*, how I put `\\S` above. The reasons for this are a bit technical, but
essentially, `\x` has a separate (non-regex) meaning, so we have to 'escape'
the `\` by putting an extra slash in front of it: `\\`. You should really read
`\\S` as `\\` + `S`, not `\` + `\S`. We will discuss this a bit more in class
since it gets tricky.

### Capture Groups

Before we end, let's introduce one more powerful feature of regular expressions:
_capture groups_. This lets us give an identity to the part of a string that
matches a text and reference it again later. 

The basic syntax for a capture group is simple: you simply surround the desired
part with parentheses: for example, 

```{webr}
str_match("Albany, NY is the state capital.", "(\\S*), NY")
```

Here, we are using the short-hand `\S` for _non-space character_ (i.e., letters,
numbers, or punctuation).[^double] Here, we see that the output of `str_match`
now returns the part of the string that matched the entire regex (`Albany, NY`)
and the part that matched the capture group (`Albany`). If we want to just get
the capture group and nothing else, we can use `str_extract` and provide the
`group` argument: 

```{webr}
str_extract("Albany, NY is the state capital.", "(\\S*), NY", group=1)
```

Extensions to `str_match_all` will return multiple matches

```{webr}
str_match_all("Albany, NY is to the north of Peekskill, NY.", "(\\S*), NY")
```

When we combine this with `str_replace`, we can actually reference the capture
group in the output: 

```{webr}
str_replace("Albany is the 6th largest city in the state and the capital of NY.", 
            "^(\\S*).*capital of (.*)\\.$", "\\1, \\2")
```

Here, `\\N` codes for the result of the $N^{\text{th}}$ capture group. 

This is very useful when dealing with semi-structured text: 

```{webr}
city_info <- c("Albany is the 6th largest city in the state and the capital of NY.",
"Trenton is a large city and the capital of NJ.",
"Hartford is the capital of CT.")

str_replace(city_info, "(\\S*).*capital of (\\S*)\\.", "\\1, \\2")
```

though this usually requires extensive trial-and-error to get the regular 
expression exactly correct.

[^double]: We code this as `\\S` for somewhat technical reasons that will be
discussed in class. 
